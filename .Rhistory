print(paste("Controles negativos:", length(neg_genes)))
pos_genes <- controls$posControls
print(paste("Controles positivos:", length(pos_genes)))
# Calculate correlation (cc) for negative controls
cc_neg <- cor(
as.vector(counts[neg_genes, ]),
as.vector(RPM_counts[neg_genes, ]),
method = "pearson"
)
# Calculate correlation (cc) for positive controls
cc_pos <- cor(
as.vector(counts[pos_genes, ]),
as.vector(RPM_counts[pos_genes, ]),
method = "pearson"
)
# Average cc (if needed)
cc_mean <- mean(c(cc_neg, cc_pos), na.rm = TRUE)
# Function to calculate CV
calculate_cv <- function(data) {
apply(data, 1, function(x) sd(x) / mean(x))
}
# CV for raw counts
cv_raw <- calculate_cv(counts)
# CV for RPM data
cv_rpm <- calculate_cv(RPM_counts)
res_rpm <- assessNormalization(
raw=counts,
normalized  = RPM_counts,
negControls = controls$negControls,
posControls = controls$posControls,
clusters    = clusters)
View(RPM_counts)
groups<-metadata$Condition
# Convert raw_ftd_counts to a matrix
counts <- as.matrix(as.data.frame(counts))
plotCountHist(raw_ftd_counts)  # Histogram of counts
plotMeanSD(raw_ftd_counts)  # Mean vs. standard deviation
RPM_counts<- as.matrix(as.data.frame(RPM_counts))
plotCountHist(RPM_counts)  # Histogram of counts
plotMeanSD(RPM_counts)  # Mean vs. standard deviation
# Check the structure after conversion
str(counts)
clusters <- defineClusters(rownames(counts))
#RPMs calculation of cc and mscr
controls <- defineControls(
counts,
tZero = 5,     # lower count bound for negative controls
tPoor = 10,     # upper count bound for negative controls
tWell = 30,   # lower count bound for positive controls
clusters)
# Subset control genes
neg_genes <- controls$negControls
print(paste("Controles negativos:", length(neg_genes)))
pos_genes <- controls$posControls
print(paste("Controles positivos:", length(pos_genes)))
# Calculate correlation (cc) for negative controls
cc_neg <- cor(
as.vector(counts[neg_genes, ]),
as.vector(RPM_counts[neg_genes, ]),
method = "pearson"
)
# Calculate correlation (cc) for positive controls
cc_pos <- cor(
as.vector(counts[pos_genes, ]),
as.vector(RPM_counts[pos_genes, ]),
method = "pearson"
)
# Average cc (if needed)
cc_mean <- mean(c(cc_neg, cc_pos), na.rm = TRUE)
# Function to calculate CV
calculate_cv <- function(data) {
apply(data, 1, function(x) sd(x) / mean(x))
}
# CV for raw counts
cv_raw <- calculate_cv(counts)
# CV for RPM data
cv_rpm <- calculate_cv(RPM_counts)
# Mean squared CV ratio (mscr) for control genes
mscr_neg <- mean((cv_rpm[neg_genes] / cv_raw[neg_genes])^2, na.rm = TRUE)
mscr_pos <- mean((cv_rpm[pos_genes] / cv_raw[pos_genes])^2, na.rm = TRUE)
# Average mscr (if needed)
mscr_mean <- mean(c(mscr_neg, mscr_pos), na.rm = TRUE)
rpm_results <-  data.frame(
cc = cc_mean,
mscr = mscr_mean,
row.names = "RPM"  # Set method name as row name
)
print(rpm_results)
normalized <- applyNormalization(
counts,
groups,
method = c("TC", "UQ", "median", "TMM", "DESeq", "PoissonSeq", "QN", "RUV"))
clusters <- defineClusters(rownames(counts))
controls <- defineControls(
counts,
tZero = 5,     # lower count bound for negative controls
tPoor = 10,     # upper count bound for negative controls
tWell = 30,   # lower count bound for positive controls
clusters)
res <- assessNormalization(
raw=counts,
normalized  = normalized,
negControls = controls$negControls,
posControls = controls$posControls,
clusters    = clusters)
cc_values <- sapply(normalized, function(x) {
cor(as.vector(counts[controls$posControls, ]), as.vector(x[controls$posControls, ]))
})
print(cc_values)
res$cc <- cc_values  # Replace with your vector
plotDANA(res)
res_updated <- rbind(res, rpm_results)
plotDANA(res_updated)
normalized
plotDANA(res_updated)
groups<-metadata$Condition
# Convert raw_ftd_counts to a matrix
counts <- as.matrix(as.data.frame(counts))
RPM_counts<- as.matrix(as.data.frame(RPM_counts))
plotCountHist(RPM_counts)  # Histogram of counts
plotMeanSD(RPM_counts)  # Mean vs. standard deviation
# Check the structure after conversion
str(counts)
clusters <- defineClusters(rownames(counts))
#RPMs calculation of cc and mscr
controls <- defineControls(
counts,
tZero = 5,     # lower count bound for negative controls
tPoor = 10,     # upper count bound for negative controls
tWell = 50,   # lower count bound for positive controls
clusters)
# Subset control miRNA
neg_miRNA <- controls$negControls
print(paste("Controles negativos:", length(neg_miRNA)))
pos_miRNA <- controls$posControls
print(paste("Controles positivos:", length(pos_miRNA)))
# Calculate correlation (cc) for negative controls
cc_neg <- cor(
as.vector(counts[neg_miRNA, ]),
as.vector(RPM_counts[neg_miRNA, ]),
method = "pearson"
)
# Calculate correlation (cc) for positive controls
cc_pos <- cor(
as.vector(counts[pos_miRNA, ]),
as.vector(RPM_counts[pos_miRNA, ]),
method = "pearson"
)
# Average cc (if needed)
cc_mean <- mean(c(cc_neg, cc_pos), na.rm = TRUE)
# Function to calculate CV
calculate_cv <- function(data) {
apply(data, 1, function(x) sd(x) / mean(x))
}
# CV for raw counts
cv_raw <- calculate_cv(counts)
# CV for RPM data
cv_rpm <- calculate_cv(RPM_counts)
# Mean squared CV ratio (mscr) for control miRNA
mscr_neg <- mean((cv_rpm[neg_miRNA] / cv_raw[neg_miRNA])^2, na.rm = TRUE)
mscr_pos <- mean((cv_rpm[pos_miRNA] / cv_raw[pos_miRNA])^2, na.rm = TRUE)
# Average mscr (if needed)
mscr_mean <- mean(c(mscr_neg, mscr_pos), na.rm = TRUE)
rpm_results <-  data.frame(
cc = cc_mean,
mscr = mscr_mean,
row.names = "RPM"  # Set method name as row name
)
print(rpm_results)
normalized <- applyNormalization(
counts,
groups,
method = c("TC", "UQ", "median", "TMM", "DESeq", "PoissonSeq", "QN", "RUV"))
res <- assessNormalization(
raw=counts,
normalized  = normalized,
negControls = controls$negControls,
posControls = controls$posControls,
clusters    = clusters)
cc_values <- sapply(normalized, function(x) {
cor(as.vector(counts[controls$posControls, ]), as.vector(x[controls$posControls, ]))
})
print(cc_values)
res$cc <- cc_values  # Replace with your vector
plotDANA(res)
res_updated <- rbind(res, rpm_results)
plotDANA(res_updated)
print(rpm_results)
plotDANA(res_updated)
controls <- defineControls(
counts,
tZero = 5,     # lower count bound for negative controls
tPoor = 10,     # upper count bound for negative controls
tWell = 30,   # lower count bound for positive controls
clusters)
# Subset control miRNA
neg_miRNA <- controls$negControls
print(paste("Controles negativos:", length(neg_miRNA)))
pos_miRNA <- controls$posControls
print(paste("Controles positivos:", length(pos_miRNA)))
# Calculate correlation (cc) for negative controls
cc_neg <- cor(
as.vector(counts[neg_miRNA, ]),
as.vector(RPM_counts[neg_miRNA, ]),
method = "pearson"
)
# Calculate correlation (cc) for positive controls
cc_pos <- cor(
as.vector(counts[pos_miRNA, ]),
as.vector(RPM_counts[pos_miRNA, ]),
method = "pearson"
)
# Average cc (if needed)
cc_mean <- mean(c(cc_neg, cc_pos), na.rm = TRUE)
# Function to calculate CV
calculate_cv <- function(data) {
apply(data, 1, function(x) sd(x) / mean(x))
}
# CV for raw counts
cv_raw <- calculate_cv(counts)
# CV for RPM data
cv_rpm <- calculate_cv(RPM_counts)
# Mean squared CV ratio (mscr) for control miRNA
mscr_neg <- mean((cv_rpm[neg_miRNA] / cv_raw[neg_miRNA])^2, na.rm = TRUE)
mscr_pos <- mean((cv_rpm[pos_miRNA] / cv_raw[pos_miRNA])^2, na.rm = TRUE)
# Average mscr (if needed)
mscr_mean <- mean(c(mscr_neg, mscr_pos), na.rm = TRUE)
rpm_results <-  data.frame(
cc = cc_mean,
mscr = mscr_mean,
row.names = "RPM"  # Set method name as row name
)
print(rpm_results)
normalized <- applyNormalization(
counts,
groups,
method = c("TC", "UQ", "median", "TMM", "DESeq", "PoissonSeq", "QN", "RUV"))
res <- assessNormalization(
raw=counts,
normalized  = normalized,
negControls = controls$negControls,
posControls = controls$posControls,
clusters    = clusters)
cc_values <- sapply(normalized, function(x) {
cor(as.vector(counts[controls$posControls, ]), as.vector(x[controls$posControls, ]))
})
print(cc_values)
res$cc <- cc_values  # Replace with your vector
plotDANA(res)
res_updated <- rbind(res, rpm_results)
plotDANA(res_updated)
groups<-metadata$Condition
# Convert raw_ftd_counts to a matrix
counts <- as.matrix(as.data.frame(counts))
RPM_counts<- as.matrix(as.data.frame(RPM_counts))
plotCountHist(RPM_counts)  # Histogram of counts
plotMeanSD(RPM_counts)  # Mean vs. standard deviation
# Check the structure after conversion
str(counts)
clusters <- defineClusters(rownames(counts))
#RPMs calculation of cc and mscr
controls <- defineControls(
counts,
tZero = 2,     # lower count bound for negative controls
tPoor = 5,     # upper count bound for negative controls
tWell = 100,   # lower count bound for positive controls
clusters)
# Subset control miRNA
neg_miRNA <- controls$negControls
print(paste("Controles negativos:", length(neg_miRNA)))
pos_miRNA <- controls$posControls
print(paste("Controles positivos:", length(pos_miRNA)))
# Calculate correlation (cc) for negative controls
cc_neg <- cor(
as.vector(counts[neg_miRNA, ]),
as.vector(RPM_counts[neg_miRNA, ]),
method = "pearson"
)
# Calculate correlation (cc) for positive controls
cc_pos <- cor(
as.vector(counts[pos_miRNA, ]),
as.vector(RPM_counts[pos_miRNA, ]),
method = "pearson"
)
# Average cc (if needed)
cc_mean <- mean(c(cc_neg, cc_pos), na.rm = TRUE)
# Function to calculate CV
calculate_cv <- function(data) {
apply(data, 1, function(x) sd(x) / mean(x))
}
# CV for raw counts
cv_raw <- calculate_cv(counts)
# CV for RPM data
cv_rpm <- calculate_cv(RPM_counts)
# Mean squared CV ratio (mscr) for control miRNA
mscr_neg <- mean((cv_rpm[neg_miRNA] / cv_raw[neg_miRNA])^2, na.rm = TRUE)
mscr_pos <- mean((cv_rpm[pos_miRNA] / cv_raw[pos_miRNA])^2, na.rm = TRUE)
# Average mscr (if needed)
mscr_mean <- mean(c(mscr_neg, mscr_pos), na.rm = TRUE)
rpm_results <-  data.frame(
cc = cc_mean,
mscr = mscr_mean,
row.names = "RPM"  # Set method name as row name
)
print(rpm_results)
normalized <- applyNormalization(
counts,
groups,
method = c("TC", "UQ", "median", "TMM", "DESeq", "PoissonSeq", "QN", "RUV"))
res <- assessNormalization(
raw=counts,
normalized  = normalized,
negControls = controls$negControls,
posControls = controls$posControls,
clusters    = clusters)
cc_values <- sapply(normalized, function(x) {
cor(as.vector(counts[controls$posControls, ]), as.vector(x[controls$posControls, ]))
})
print(cc_values)
res$cc <- cc_values  # Replace with your vector
plotDANA(res)
res_updated <- rbind(res, rpm_results)
plotDANA(res_updated)
res <- assessNormalization(
raw=counts,
normalized  = normalized,
negControls = controls$negControls,
posControls = controls$posControls,
clusters    = clusters)
# For each method in DANA's results (e.g., "TC", "QN")
for (method in rownames(res)) {
# Get normalized counts for the method
norm_counts <- normalized[[method]]  # Replace with your DANA-normalized data
# Compute mscr (same logic as RPM)
cv_norm <- apply(norm_counts, 1, function(x) sd(x)/mean(x))
mscr_neg <- mean((cv_norm[neg_miRNA] / cv_raw[neg_miRNA])^2, na.rm = TRUE)
mscr_pos <- mean((cv_norm[pos_miRNA] / cv_raw[pos_miRNA])^2, na.rm = TRUE)
res[method, "mscr"] <- mean(c(mscr_neg, mscr_pos), na.rm = TRUE)
# Compute cc (if missing)
if (is.na(res[method, "cc"])) {
res[method, "cc"] <- cor(
as.vector(counts[pos_miRNA, ]),
as.vector(norm_counts[pos_miRNA, ])
)
}
}
res
normalized <- applyNormalization(
counts,
groups,
method = c("TC", "UQ", "median", "TMM", "DESeq", "PoissonSeq", "QN", "RUV"))
res <- assessNormalization(
raw=counts,
normalized  = normalized,
negControls = controls$negControls,
posControls = controls$posControls,
clusters    = clusters)
# For each method in DANA's results (e.g., "TC", "QN")
for (method in rownames(res)) {
# Get normalized counts for the method
norm_counts <- normalized[[method]]  # Replace with your DANA-normalized data
# Compute mscr (same logic as RPM)
cv_norm <- apply(norm_counts, 1, function(x) sd(x)/mean(x))
mscr_neg <- mean((cv_norm[neg_miRNA] / cv_raw[neg_miRNA])^2, na.rm = TRUE)
mscr_pos <- mean((cv_norm[pos_miRNA] / cv_raw[pos_miRNA])^2, na.rm = TRUE)
res[method, "mscr"] <- mean(c(mscr_neg, mscr_pos), na.rm = TRUE)
# Compute cc (if missing)
if (is.na(res[method, "cc"])) {
res[method, "cc"] <- cor(
as.vector(counts[pos_miRNA, ]),
as.vector(norm_counts[pos_miRNA, ])
)
}
}
res
normalized <- applyNormalization(
counts,
groups,
method = c("TC", "UQ", "median", "TMM", "DESeq", "PoissonSeq", "QN", "RUV"))
res <- assessNormalization(
raw=counts,
normalized  = normalized,
negControls = controls$negControls,
posControls = controls$posControls,
clusters    = clusters)
res
for (method in rownames(res)) {
# Get normalized counts for the method
norm_counts <- normalized[[method]]  # Replace with your DANA-normalized data
# Compute mscr (same logic as RPM)
cv_norm <- apply(norm_counts, 1, function(x) sd(x)/mean(x))
mscr_neg <- mean((cv_norm[neg_miRNA] / cv_raw[neg_miRNA])^2, na.rm = TRUE)
mscr_pos <- mean((cv_norm[pos_miRNA] / cv_raw[pos_miRNA])^2, na.rm = TRUE)
res[method, "mscr"] <- mean(c(mscr_neg, mscr_pos), na.rm = TRUE)
# Compute cc (if missing)
if (is.na(res[method, "cc"])) {
res[method, "cc"] <- cor(
as.vector(counts[pos_miRNA, ]),
as.vector(norm_counts[pos_miRNA, ])
)
}
}
res
normalized$DESeq
class(normalized)
names(normalized)  # e.g., ["TC", "TMM", "DESeq", ...]
# Assign your RPM-normalized matrix to the list
normalized$RPM <- RPM_counts  # Ensure RPM_normalized is a matrix/data.frame
names(normalized)  # e.g., ["TC", "TMM", "DESeq", ...]
dim(RPM_normalized)       # Should match
dim(normalized$RPM)       # Should match
dim(normalized$TC)
rownames(normalized$RPM)  # Should match
rownames(normalized$TC)
res <- assessNormalization(
raw=counts,
normalized  = normalized,
negControls = controls$negControls,
posControls = controls$posControls,
clusters    = clusters)
res
cc_values <- sapply(normalized, function(x) {
cor(as.vector(counts[controls$posControls, ]), as.vector(x[controls$posControls, ]))
})
print(cc_values)
res$cc <- cc_values  # Replace with your vector
plotDANA(res)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
desc::desc_get_authors()
library(miRPM)
packageDescription("miRPM")$Author
devtools::document()
devtools::document()
devtools::document()
?miRPM
devtools::document()
?miRPM
devtools::document()
?miRPM
devtools::document()
?miRPM
devtools::document()
devtools::document()
devtools::document()
?miRPM
devtools::document()
?miRPM
usethis::use_citation()
devtools::document()
devtools::document()
devtools::document()
?miRPM
citation("miRPM")
devtools::document()
citation("miRPM")
?miRPM
install.packages(c("pkgdown","usethis"))
install.packages(c("pkgdown", "usethis"))
usethis::use_pkgdown()
pkgdown::build_site()
usethis::use_readme_rmd(open = TRUE)
pkgdown::build_site()
devtools::document()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
rmarkdown::render("README.Rmd")
pkgdown::build_site()
usethis::use_readme_rmd(open = TRUE)
devtools::build_readme()   # (mejor que render manual)
pkgdown::build_site()
dir.create("pkgdown")
dir.create("pkgdown", showWarnings = FALSE)
file.create("pkgdown/index.md")
file.edit("pkgdown/index.md")
citation("miRPM")
library(miRPM)
devtools::build_readme()  # genera README.md desde el README.Rmd
pkgdown::build_site()     # reconstruye la web
library(miRPM)
devtools::build_readme()  # genera README.md desde el README.Rmd
pkgdown::build_site()     # reconstruye la web
devtools::build_readme()  # genera README.md desde el README.Rmd
pkgdown::build_site()     # reconstruye la web
devtools::build_readme()  # genera README.md desde el README.Rmd
pkgdown::build_site()     # reconstruye la web
library(miRPM)
devtools::build_readme()  # genera README.md desde el README.Rmd
devtools::build_readme()  # genera README.md desde el README.Rmd
pkgdown::build_site()     # reconstruye la web
devtools::build_readme()  # genera README.md desde el README.Rmd
pkgdown::build_site()     # reconstruye la web
devtools::build_readme()  # genera README.md desde el README.Rmd
pkgdown::build_site()     # reconstruye la web
devtools::build_readme()  # genera README.md desde el README.Rmd
pkgdown::build_site()     # reconstruye la web
pkgdown::clean_site()
pkgdown::build_site()   # aquí debería salir “Writing index.html”
usethis::use_pkgdown_github_pages()   # crea workflow + configura gh-pages
pkgdown::build_site(preview = FALSE)  # opcional
pkgdown::build_site(preview = FALSE)
file.create("docs/.nojekyll")   # muy importante
devtools::build_readme()  # genera README.md desde el README.Rmd
pkgdown::build_site()     # reconstruye la web
devtools::build_readme()  # genera README.md desde el README.Rmd
pkgdown::build_site()     # reconstruye la web
pkgdown::build_site()     # reconstruye la web
